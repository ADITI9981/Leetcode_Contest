class Solution {
public:
    int minTime(int n, vector<vector<int>>& edges) {
        using ll = long long;

        vector<vector<tuple<int,ll,ll>>> graph(n);
        for(auto& e : edges){
            int u =e[0], v = e[1];
            ll start = e[2], end = e[3];
            if (start>end) continue;
            graph[u].emplace_back(v,start,end);
        }
        priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<>> pq;
        vector<ll> minTime(n,LLONG_MAX);

        pq.emplace(0,0);
        minTime[0]=0;

        while(!pq.empty()){
            auto [time,u]= pq.top();
            pq.pop();
            if(u==n-1) return time;

            if(time>minTime[u]) continue;
            for(auto&[v,start,end]: graph[u]){
                ll departTime = max(time,start);
                if(departTime>end) continue;
                ll arrivalTime = departTime+1;

                if (arrivalTime<minTime[v]){
                    minTime[v] = arrivalTime;
                    pq.emplace(arrivalTime,v);
                }
            }
            if(time+1<minTime[u]){
                minTime[u] = time+1;
                pq.emplace(time+1,u);
            }
        }
        return -1;
    }
};Â©leetcode
